<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="manifest.json"><link rel="shortcut icon" href="favicon.ico"><link href="https://fonts.googleapis.com/css2?family=Lilita+One&display=swap" rel="stylesheet"><link href="../dist/output.css" rel="stylesheet"><title>Klo Box App</title><style>body,html{height:100%;margin:0;padding:0;width:100%}body{font-family:Roboto,sans-serif;font-size:13px;-webkit-font-smoothing:antialiased}</style><script defer="defer" src="/static/js/main.e0ac4846.js"></script><link href="/static/css/main.05c65ee8.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><script id="vshader" type="x-shader/x-vertex">precision highp float;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform float time;
    attribute vec3 position;
    attribute vec2 uv;
    attribute vec3 translate;
    varying vec2 vUv;
    varying float vScale;
    void main() {
      vec4 mvPosition = modelViewMatrix * vec4( translate, 1.0 );
      vec3 trTime = vec3(translate.x + time,translate.y + time,translate.z + time);
      float scale =  sin( trTime.x * 2.1 ) + sin( trTime.y * 3.2 ) + sin( trTime.z * 4.3 );
      vScale = scale;
      scale = scale * 10.0 + 10.0;
      mvPosition.xyz += position * scale;
      vUv = uv;
      gl_Position = projectionMatrix * mvPosition;
    }</script><script id="fshader" type="x-shader/x-fragment">precision highp float;
    uniform sampler2D map;
    varying vec2 vUv;
    varying float vScale;
    // HSL to RGB Convertion helpers
    vec3 HUEtoRGB(float H){
      H = mod(H,1.0);
      float R = abs(H * 6.0 - 3.0) - 1.0;
      float G = 2.0 - abs(H * 6.0 - 2.0);
      float B = 2.0 - abs(H * 6.0 - 4.0);
      return clamp(vec3(R,G,B),0.0,1.0);
    }
    vec3 HSLtoRGB(vec3 HSL){
      vec3 RGB = HUEtoRGB(HSL.x);
      float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;
      return (RGB - 0.5) * C + HSL.z;
    }
    void main() {
      vec4 diffuseColor = texture2D( map, vUv );
      gl_FragColor = vec4( diffuseColor.xyz * HSLtoRGB(vec3(vScale/5.0, 1.0, 0.5)), diffuseColor.w );
      if ( diffuseColor.w < 0.5 ) discard;
    }</script><script type="x-shader/x-vertex" id="vertexShader">varying vec3 vWorldPosition;
		void main() {
			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}</script><script type="x-shader/x-fragment" id="fragmentShader">uniform vec3 topColor;
		uniform vec3 bottomColor;
		uniform float offset;
		uniform float exponent;
		varying vec3 vWorldPosition;
		void main() {
			float h = normalize( vWorldPosition + offset ).y;
			gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
		}</script><div id="root"></div></body></html>